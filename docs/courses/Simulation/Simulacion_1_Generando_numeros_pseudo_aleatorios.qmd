---
title: "Simulación Estadística"
subtitle: "Unidad 1: Generando números pseudo aleatorios"
author:
  - name: Francisco Plaza Vega
    email: francisco.plaza.v@usach.cl
    affiliation: Ingeniería en Estadística
# date: 11/02/23
# date-format: "DD/MM/YY"
format:
  # html:
  #   toc: true
  #   toc-location: left
  #   toc-depth: 2
  #   toc-expand: 2
  #   html-math-method: katex
  #   theme: [sketchy, styles.scss]
  revealjs:
    self-contained: false
    slide-number: c/t
    width: 1600
    height: 900
    center: false
    # footer: "26229 Simulación Estadística - S1/2024"
    theme: [simple, styles.scss]
    echo: true
    multiplex: true
    code-link: true
    # title-slide-attributes:
    # data-background-color: "#ffffff"
fig-align: center
logo: "images/Usach_P2.png"
editor: source
incremental: true
center-title-slide: true
slide-number: true
lang: es
highlight-style: github
transition: fade
toc: false
toc-title: "Contenidos"
toc-expand: false
toc-depth: 2
number-sections: true
number-depth: 2
bibliography: refs.bib
---


```{r}
#| echo: false
library(reticulate)
# use_python('C:/ProgramData/Anaconda3/python.exe')
```

# Simulación Estadística {background-color="#00A499"}

## ¿Qué es la simulación?

::: {.definition}
El acto de ["_simular_"]{.green}:<br/>

- Según el [Diccionario de la Lengua Española de la RAE](https://www.rae.es/drae2001/simular), ["_simular_"]{.green} significa representar algo, fingiendo o imitando lo que no es.

- De acuerdo con [TheFreeDictionary](https://es.thefreedictionary.com/simular), ["_simular_"]{.green} es hacer creer una cosa que no es verdad con palabras, gestos o acciones, y también se refiere a representar algo fingiendo lo que no es.

- [WordReference](https://www.wordreference.com/definicion/simular#:~:text=tr.,simul%C3%B3%20que%20no%20le%20importaba.) define ["_simular_"]{.green} como representar una cosa fingiendo o imitando lo que no es.
:::

---

::: {.definition}
[de  ChatGPT]{.green}<br/>
_Estas definiciones resaltan la idea de crear una apariencia o representación de algo que no es real o verdadero, ya sea mediante acciones, palabras o gestos. En un contexto más amplio, la simulación puede usarse en diversos campos, como la ciencia, la tecnología y el arte, para representar o modelar situaciones, procesos o sistemas de manera virtual o teórica._ 
<br/>

_El término "simular" proviene del latín "_simulāre_" y tiene varias definiciones que se centran en la idea de representación o imitación_
:::

---

La experimentación directa sobre la realidad puede tener muchos inconvenientes, entre otros:

- [Coste elevado]{.green}: por ejemplo cuando las pruebas son destructivas o si es necesario esperar mucho tiempo para observar los resultados.

- [Puede no ser ética]{.green}: por ejemplo la experimentación sobre seres humanos o la dispersión de un contaminante.

- [Puede resultar imposible]{.green}: por ejemplo cuando se trata de un acontecimiento futuro o una alternativa en el pasado.

## Simulación estadística 

::: {.small}

- Para estadísticos e investigadores, el término ['simulación']{.green} describe una gran cantidad de técnicas variadas y útiles, todas relacionadas con la imitación de las reglas de un modelo de algún tipo. Estas técnicas permiten a los investigadores y analistas estudiar y predecir el comportamiento del sistema bajo diferentes condiciones y escenarios sin necesidad de experimentos físicos o reales.

- En la simulación estadística, se emplean modelos probabilísticos para representar la incertidumbre y la variabilidad inherente a los fenómenos reales. Estos modelos pueden ser tan simples como distribuciones de probabilidad básicas o tan complejos como sistemas dinámicos y redes neuronales. Al ejecutar la simulación múltiples veces, se obtienen distribuciones de resultados que ayudan a comprender mejor el sistema y a evaluar riesgos, eficiencia, y otras métricas importantes.

- El objetivo es a menudo explorar ["qué pasaría si"]{.green} en situaciones donde los experimentos reales son impracticables, costosos, peligrosos o éticamente inviables.

:::

---

::: {.example}
[Por ejemplo:]{.blue}<br/>

- [En ingeniería]{.green}, los estudios de simulación pueden usarse para predecir cómo se comportará una estructura bajo ciertas cargas sin tener que construirla físicamente. 

- [En finanzas]{.green}, pueden ayudar a evaluar los riesgos de diferentes inversiones o estrategias de mercado. 

- [En medicina]{.green}, se pueden utilizar para prever la progresión de enfermedades o la respuesta a distintos tratamientos.
:::
<br/>

. . .

Los estudios de simulación [_dependen de la generación de datos y escenarios artificiales_]{.green}, pero [buscan producir resultados que sean lo suficientemente precisos]{.green} y realistas como para informar decisiones o entender mejor un sistema o fenómeno.

---

::: {.example}
[Ejemplo práctico]{.blue}<br/>
Supongamos que comenzamos a coleccionar láminas para un álbum con $n = 75$ láminas, que se venden sobres con $m = 6$ láminas y cada sobre tiene un costo de $\$800$, y que estamos interesados en el número de sobres que hay que comprar para completar la colección, por ejemplo en su valor medio. 
:::
<br/>

. . .

Podemos aproximar la distribución del número de sobres para completar la colección a partir de $nsim = 1000$ simulaciones de coleccionistas de láminas

--- 

:::: {.columns}

::: {.column width="50%"}

### Código

```{r}
#| eval: false
#| include: true
# Parámetros
n <- 75 # Número total de láminas del álbum
m <- 6  # Número de láminas en cada sobre
repe <- TRUE # Láminas repetidas en cada sobre
# Número de simulaciones
nsim <- 1000
# Resultados simulación
nsobres <- numeric(nsim)
# evol <- vector("list", nsim)
# Fijar semilla
set.seed(1)
# Bucle simulación
for (isim in 1:nsim) {
  # seed <- .Random.seed    # .Random.seed <- seed
  album <- logical(n)
  i <- 0 # Número de sobres
  while(sum(album) < n) {
    i <- i + 1
    album[sample(n,m, replace = repe)] <- TRUE
  }
  nsobres[isim] <- i
}

hist(nsobres, breaks = "FD", freq = FALSE,
     main = "", xlab = "Número de sobres")
lines(density(nsobres))
```
:::

::: {.column width="50%"}

### Histograma
```{r}
#| eval: true
#| echo: false
# Parámetros
n <- 75 # Número total de láminas del álbum
m <- 6  # Número de láminas en cada sobre
repe <- TRUE # Láminas repetidas en cada sobre
# Número de simulaciones
nsim <- 1000
# Resultados simulación
nsobres <- numeric(nsim)
# evol <- vector("list", nsim)
# Fijar semilla
set.seed(1)
# Bucle simulación
for (isim in 1:nsim) {
  # seed <- .Random.seed    # .Random.seed <- seed
  album <- logical(n)
  i <- 0 # Número de sobres
  while(sum(album) < n) {
    i <- i + 1
    album[sample(n,m, replace = repe)] <- TRUE
  }
  nsobres[isim] <- i
}

hist(nsobres, breaks = "FD", freq = FALSE,
     main = "", xlab = "Número de sobres")
lines(density(nsobres))
```
:::
::::

--- 

:::: {.columns}
::: {.column width="50%"}

:::{.small}
Aproximación por simulación del número medio de sobres para completar la colección:
:::

```{r}
#| eval: true
#| echo: true
mean(nsobres)
```

<br/>

::: {.small}
Número mínimo de sobres para asegurar de que se completa la colección con una probabilidad del 95%:
:::

```{r}
#| eval: true
#| echo: true
quantile(nsobres, probs = 0.95)
```

<br/>

::: {.small}
Reserva de dinero para poder completar la colección el 95% de las veces:
:::

```{r}
#| eval: true
#| echo: true
quantile(nsobres, probs = 0.95)*800
```
:::

::: {.column width="50%"}

Aproximaciones por simulación de la distribución del número de sobres para completar la colección, de su valor esperado (línea vertical continua) y del cuantil 0.95 (línea vertical discontinua).

```{r}
#| eval: true
#| echo: true
sol = mean(nsobres)
nmin = quantile(nsobres, probs = 0.95)
hist(nsobres, breaks = "FD", freq = FALSE,
     main = "", xlab = "Número de sobres")
lines(density(nsobres))
abline(v = sol)
abline(v = nmin, lty = 2)

```

:::

::::

## Aplicaciones de simulación

La simulación resulta de utilidad en multitud de contextos diferentes. Los principales campos de aplicación en estadística pueden ser:

- Muestreo, remuestreo…

- Aproximación de distribuciones (de estadísticos, estimadores…)

- Realización de contrastes, intervalos de confianza…

- Comparación de estimadores, contrastes…

- Validación teoría (distribución asintótica…)

- Inferencia Bayesiana


## Tipos de números aleatorios

El primer requisito para poder realizar simulación estocástica sería disponer de números aleatorios. Se distingue entre tres tipos de secuencias:

- [números aleatorios puros (true random):]{.orange} se caracteriza porque no existe ninguna regla o plan que nos permita conocer sus valores.

- [números pseudo-aleatorios:]{.orange} simulan realizaciones de una variable aleatoria (uniforme),

- [números cuasi-aleatorios:]{.orange} secuencias deterministas con una distribución más regular en el rango considerado.

---

### Números aleatorios puros

Normalmente son obtenidos por procesos físicos (loterías, ruletas, ruidos…) y, hasta hace una décadas, se almacenaban en tablas de dígitos aleatorios. Por ejemplo, en 1955 la Corporación RAND publicó el libro [*A Million Random Digits with 100,000 Normal Deviates*]{.orange} que contenía números aleatorios generados mediante una ruleta electrónica conectada a una computadora

![Portada del libro *A Million Random Digits with 100,000 Normal Deviates* [@hammersley1955million]. ](images/rand_book.jpg){width="20%" fig-align="center"}

---

El procedimiento que se utilizaba para seleccionar de una tabla, de forma manual, números aleatorios en un rango de 1 a $m$ era el siguiente:

- Se selecciona al azar un punto de inicio en la tabla y la dirección que se seguirá.

- Se agrupan los dígitos de forma que “cubran” el valor de $m$.

- Se va avanzado en la dirección elegida, seleccionando los valores menores o iguales que $m$ y descartando el resto.

---

### Números cuasi-aleatorios

Algunos problemas, como la integración numérica (que veremos más adelante en este curso), no dependen realmente de la aleatoriedad de la secuencia. Para evitar generaciones poco probables, se puede recurrir a secuencias [*cuasi-aleatorias*]{.orange}, también denominadas sucesiones de baja discrepancia (hablaríamos entonces de métodos cuasi-Monte Carlo, por ejemplo). La idea sería que la proporción de valores en una región cualquiera sea siempre aproximadamente proporcional a la medida de la región (como sucedería en media con la distribución uniforme, aunque no necesariamente para una realización concreta).


----

Por ejemplo, el paquete randtoolbox de R implementa métodos para la generación de secuencias cuasi-aleatorias 

```{r}
#| eval: true
#| echo: true
#| fig-cap: "Secuencias cuasi-aleatorias bidimensionales obtenidas con los métodos de Halton (izquierda), Sobol (centro) y Torus (derecha)."
library(randtoolbox)
n <- 2000
par.old <- par(mfrow = c(1, 3))
plot(halton(n, dim = 2), xlab = 'x1', ylab = 'x2')
plot(sobol(n, dim = 2), xlab = 'x1', ylab = 'x2')
plot(torus(n, dim = 2), xlab = 'x1', ylab = 'x2')
```

---

### Números pseudo-aleatorios

La mayoría de los métodos de simulación se basan en la posibilidad de [generar números pseudo-aleatorios]{.orange} que imiten las propiedades de valores independientes de la distribución $U \sim (0,1)$, es decir, que imiten las propiedades de una muestra aleatoria simple^[Se debe distinguir entre secuencia y muestra. En un problema de [inferencia]{.green}, en principio estamos interesados en una característica desconocida de la población. En cambio, en un problema de [simulación]{.green}, [la población]{.orange} es el modelo y lo conocemos por completo (no obstante el problema de simulación puede surgir como solución de un problema de inferencia)] de esta distribución.

El procedimiento habitual para obtener estas secuencias es emplear un algoritmo recursivo denominado generador:

$$x_i = f(x_{i-1}, x_{i-2}, \ldots, x_{i-k})$$

donde: $k$ es el orden del generador  y $(x_{0}, x_{1}, \ldots, x_{k-1})$ es la semilla (estado inicial).

El periodo o longitud del ciclo es la longitud de la secuencia antes de que vuelva a repetirse. Lo denotaremos por $p$.

---

::: {.definition}
Los números de la sucesión son predecibles, conociendo el [algoritmo]{.green} y la [semilla]{.green}. Sin embargo, si no se conociesen, no se debería poder distinguir una serie de números pseudoaleatorios de una sucesión de números verdaderamente aleatoria (utilizando recursos computacionales razonables). 
:::

<br/>
En caso contrario esta predecibilidad puede dar lugar a algunos problemas. Acá se muestran algunos artículos que ejemplifican esta situación:

  - [Cryptanalysis of the Random Number Generator of the Windows Operating System](http://eprint.iacr.org/2007/419).
  
  - [Attacks on Pseudo Random Number Generators Hiding a Linear Structure](https://eprint.iacr.org/2021/1204).
  
  - [Potential Weaknesses In Pseudorandom Number Generators](https://www.cs.tufts.edu/comp/116/archive/fall2013/ali.pdf).
  
  - [Security problems for a pseudorandom sequence generator based on the Chen chaotic system](https://www.sciencedirect.com/science/article/abs/pii/S0010465513001604).

---

- Como regla general, por lo menos mientras se está desarrollando un código o análisis particular, interesa fijar la semilla de aleatorización.

- Permite la reproducibilidad de los resultados.

- Facilita la depuración del código.

---

:::{.alert}
[Tarea:]{.orange}</br>
Revisar artículo *[A search for good pseudo-random number generators: Survey and empirical studies](https://www.sciencedirect.com/science/article/pii/S1574013722000144?casa_token=qAGiENpFHZwAAAAA:_BzpZp7UVbTaP517SK9ObEBs45Yg1niOBJlPg6EjIWkTU9nyZ0CuFf8qUp6_R0vZxJ6AQP4jFg)* [@bhattacharjee2022search].
:::

---

### La Semilla

Los computadores son máquinas determinísticas, capaces de seguir solamente reglas predeterminadas. La solución es emplear [números pseudo aleatorios]{.green}, que como esquema general, funcionan de la siguiente manera:

- Se inicia una secuencia arbitraria de [bytes]{.orange}. Los [bits]{.orange} de esa secuencia son interpretados como los digitos de un número aleatorio $Uniforme(0,1)$, expresado de forma binaria hasta una cantidad fija de lugares decimales.

- Luego se aplica una compleja función matemática (de forma determinística) que transforma el arreglo (o matriz) de bytes en un nuevo arreglo de bytes. El nuevo arreglo de bytes es técnicamente una función determinista del anterior, pero en la práctica no se parece mucho al arreglo original.

- Voltear un solo bit en la matriz de bytes original podría cambiar los bits en cualquier parte de la salida. La nueva matriz se trata como una nueva variable $Uniforme(0,1)$, y así sucesivamente.


--- 

Una [ventaja del uso de números pseudo aleatorios]{.orange} es que puede configurar manualmente la matriz de bytes inicial al comienzo de un programa. Esto se denomina la [semilla]{.green}. Lo anterior tiene algunos usos:

- Si hay un error en algún programa aleatorio que sólo ocurre algunas veces, puede hacerse perfectamente reproducible y averiguar qué está pasando.

- Si se necesita que los resultados de los análisis sean exactamente reproducibles, se puede establecer la semilla en la secuencia de comandos.

- Cuando escribe pruebas, puede establecer la semilla y asegurarse de que el resultado sea exactamente el esperado.

---

En Python
```{python}
#| echo: true
import random
random.seed(10)
print(random.random())
```


En R
```{r}
#| echo: true
set.seed(10)
print(runif(1))
```


---

### Generando números aleatorios en *R*

La generación de números pseudo-aleatorios en R es una de las mejores disponibles en paquetes estadísticos. Entre las herramientas implementadas en el paquete base de R podemos destacar:

- ```set.seed(entero)```: permite establecer la semilla (y el generador).

- ```RNGkind()```: selecciona el generador.

- ```r_distribución(n,...)```: genera valores aleatorios de la correspondiente distribución. Por ejemplo, ```runif(n, min = 0, max = 1)```, generaría $n$ valores de una uniforme. Se puede acceder al listado completo de las funciones disponibles en el paquete ```stats``` mediante el comando ```?distributions```.

- ```sample()```: genera muestras aleatorias de variables discretas y permutaciones.

- ```simulate()```: genera realizaciones de la respuesta de un modelo ajustado.

---

::: {.definition}
[La Semilla]{.green} </br>

- La semilla se almacena en ```.Random.seed```:

- Inicialmente no existe. La recomendación es establecerla con ```set.seed()```, en caso contrario se generará a partir del reloj del sistema cuando se necesite.

- Se almacena como un objeto oculto en el entorno de trabajo (o entorno global ```.GlobalEnv```). Con las opciones por defecto de R, si al terminar una sesión almacenamos el entorno (en un fichero ```.RData```), al iniciar una nueva sesión se restaurará también la semilla (y se podría continuar con las simulaciones).

- Es un vector de enteros cuya estructura depende del tipo de generador, por lo que no debería ser modificado manualmente.

- Puede ser recomendable almacenar (el objeto completo) antes de generar simulaciones, e.g. ```seed <- .Random.seed```. Esto permite reproducir los resultados y facilita la depuración de posibles errores.

:::

## Práctica: Variables aleatorias Bernoulli

::: {.example}
[Monedas al aire: Variables aleatorias Bernoulli]{.green}</br>

Uno de los [modelos probabilísticos más intuitivos]{.orange} es simplemente lanzar una moneda (equilibrada o no).

- Digamos que la probabilidad de obtener [cara]{.green} es $p$, por lo tanto, la probabilidad de obtener [sello]{.green} es $1-p$.

- En términos probabilisticos podríamos decir que el lanzamiento de esta moneda corresponde a una [Variable aleatoria Bernoulli]{.orange}. También denotado por $Bernoulli(p)$.

:::

---

<!-- https://livebook.manning.com/book/data-science-bookcamp/chapter-3/21 -->
Probemos generando el experimento de manera computacional:

::: {.panel-tabset} 

## Python

::: {.columns}

::: {.column width="50%"}


```{python}
#| eval: false
#| echo: true

# importando librerías
import matplotlib.pyplot as plt
from scipy.stats import bernoulli

#Datos
p= 0.7 #Probabilidad de ocurrencia 
n = 1000 #Tamaño de la muestra
muestras = bernoulli.rvs(p,size=n) 
plt.figure(figsize=(5,4))
plt.hist(muestras);
plt.xlabel('Lanzamiento de la moneda')
plt.ylabel('Conteo');
plt.show()
```

:::

::: {.column width="50%"}

```{python} 
#| echo: false
#| fig-align: center

# importando librerías
import matplotlib.pyplot as plt
from scipy.stats import bernoulli

#Datos
p= 0.7 #Probabilidad de ocurrencia 
n = 1000 #Tamaño de la muestra
muestras = bernoulli.rvs(p,size=n)
plt.figure(figsize=(5,4))
plt.hist(muestras);
plt.xlabel('Lanzamiento de la moneda')
plt.ylabel('Conteo');
plt.show()
```

:::

:::

## R

::: {.columns}

::: {.column width="50%"}


```{r}
#| eval: false
#| echo: true

n = 1000
p = 0.7
moneda = rbinom(n, size = 1, prob = p)
moneda = ifelse(moneda == 0, "Cara", "Sello")
barplot(table(moneda)/n, 
        col = "lightblue", ylim = c(0,1), 
        ylab = "Probabilidad")
abline(h=0.7, col= "green", lwd = 4)
```

:::

::: {.column width="50%"}

```{r} 
#| echo: false
#| fig-align: center

n = 1000
p = 0.7
moneda = rbinom(n, size = 1, prob = p)
moneda = ifelse(moneda == 0, "Cara", "Sello")
barplot(table(moneda)/n, 
        col = "lightblue", ylim = c(0,1), 
        ylab = "Probabilidad")
abline(h=0.7, col= "green", lwd = 4)
```

:::

:::

:::

- La asignación de $p=0.7$ a la probabilidad de obtener *'cara'* y a $1-p=0.3$ la probabilidad de obtener *'sello'*, es denominado la función de masa de probabilidad, para esta variable aleatoria en particular.

- Es conveniente describir la variable aleatoria en términos de números en vez de lados de una moneda. Por convención denominamos $cara=1$ y $sello=0$. 

---

::: {.example}
[Ejemplo]{.blue}</br>

Dos amigos efectúan una apuesta a partir de lanzamiento de una moneda. Un amigo le dice al otro:

  > Te daré 5 por cada cara que salga y tu me pagarás 2 por cada sello que aparezca.

:::

- El pago promedio entonces será:
  $$ \mathbb{E}(pago) = 0.7 \times 5 + 0.3 \times (-2) = 2.9 $$
  
- Entonces, si lanzamos la moneda $N$ veces, donde $N$ es un número muy grande, el pago final será de aproximadamente $(2.9 \times N)$.

---

Podemos observar cómo una variable aleatoria [Bernoulli]{.green}, podría generalizarse a algo como el lanzamiento de un dado, donde la función de masa de probabilidad asignaría una probabilidad a los números $0-5$. En este caso, denotamos como $p_i$ la probabilidad del $i$-ésimo resultado. Además:

  - Todos los $p_i$ son no negativos, y
  
  - $\sum_{i=0}^n p_i = 1$, con $n=5$. 

Una variable de tipo [Bernoulli]{.green} es denominada una [variable aleatoria discreta]{.green}. Esto significa que:

  - Tiene un número finito de resultados posibles o
  
  - Todos sus posibles resultados pueden ser listados.
  
## Variables aleatorias Uniformes

::: {.alert}
[Lanzando dardos: Variables aleatorias Uniformes]{.green}</br>

Lo opuesto a las variables aleatorias discretas, son las [variables aleatorias contínuas]{.green}, que pueden tomar cualquier valor entre un rango de números.

- La variable aleatoria contínua más simple para simular es la denominada [Uniforme]{.green}, denotada por $Uniforme(a,b)$.

- Una v.a. $Uniforme(a,b)$, siempre se encontrará entre los números $a$ y $b$ con una probabilidad igual de estar en cualquier lugar dentro de ese rango.

:::

---

Probemos generando una v.a. $Uniforme(1,5)$, de manera computacional:

::: {.panel-tabset}

## Python

::: {.columns}

::: {.column width="50%"}

```{python} 
#| eval: false
#| include: true
import numpy as np
import matplotlib.pyplot as plt

a, b = 1,5 #Rango 
n = 1000 #Tamaño de la muestra
muestras = np.random.uniform(low = a, high = b, size=n) 
plt.figure(figsize=(5,4))
count, bins, ignored = plt.hist(muestras, bins = 15, density=True)
plt.plot(bins, np.ones_like(bins)/(b-a), linewidth=2, color='r')
plt.xlim([0, 6]); plt.ylim([0, 1])
plt.xlabel('x')
plt.ylabel('Probabilidad');
plt.show()
```

:::

::: {.column width="50%"}

```{python}
#| echo: false
#| fig-align: center

import numpy as np
import matplotlib.pyplot as plt

a, b = 1,5 #Rango 
n = 1000 #Tamaño de la muestra
muestras = np.random.uniform(low = a, high = b, size=n) 
plt.figure(figsize=(5,4))
count, bins, ignored = plt.hist(muestras, bins = 15, density=True)
plt.plot(bins, np.ones_like(bins)/(b-a), linewidth=2, color='r')
plt.xlim([0, 6]); plt.ylim([0, 1]);
plt.xlabel('$x$')
plt.ylabel('Probabilidad');
plt.show()
```

:::

:::

## R

::: {.columns}

::: {.column width="50%"}

```{r} 
#| eval: false
#| include: true
n = 1000
a = 1
b = 5
muestras = runif(n, a, b)
hist(muestras, freq = FALSE,
     col = "lightblue", 
     ylim = c(0,1), xlim = c((a-1),(b+1)),
     ylab = "Probabilidad", main=NULL)
abline(h=(1/(b-a)), col= "green", lwd = 4)
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-align: center

n = 1000
a = 1
b = 5
muestras = runif(n, a, b)
hist(muestras, freq = FALSE,
     col = "lightblue", 
     ylim = c(0,1), xlim = c((a-1),(b+1)),
     ylab = "Probabilidad", main=NULL)
abline(h=(1/(b-a)), col= "green", lwd = 4)
```

:::

:::

:::

Para v.a. discretas, la función de masa de probabilidad asigna una probabilidad finita a cada resultado posible. Para v.a. continuas, cada resultado exacto, tiene probabilidad 0, pero ciertos rangos tienen mayor probabilidad que otros. Denominamos a esta función la [función de densidad de probabilidad]{.orange} (pdf, por su sigla en inglés: *probability density function*). En el caso de la v.a. Uniforme, su pdf es:

  $$p(x) = \frac{1}{(b-a)}$$



---

::: {.alert}
[Un recordatorio...]{.green}</br>

- Similar a las funciones de masa de probabilidad, las restricciones de la pdf $f$ son:

  - $f(x)$ no es nunca negativa, y
  
  - El área total bajo la curva de $f(x)$ es igual a 1. 
  
- Cualquier $f$ que cumple estos requisitos, es una pdf válida. 

- Relacionado con la pdf, está la [Función de distribución acumulada]{.orange} (cdf, por su sigla en inglés: *cummulative distribution function*). Por convención, se utiliza la munúscula $f()$ para denotar a la pdf, y la mayúscula $F()$ para denotar a la cdf.

- $F(x)$ es la probabilidad de que el valor de una variable aleatoria sea $\leq x$. Así, $F(x)$ es una función no decreciente que se aproxima a cero cuando $x \to -\infty$ y se aproxima a uno cuando $x \to \infty$. 

:::

---

### Distribución [Uniforme]{.green} y los números pseudo-aleatorios

La distribución [Uniforme]{.green} es una de las más sencillas de entender y constituye la base para construir distribuciones más complejas, en términos teóricos y matemáticos. 

::: {.example}
[Por ejemplo:]{.orange}

- Si se quiere simular una v.a. $Bernoulli(p)$, se puede simular una variable aleatoria $u$ desde una distribución $Uniforme(0,1)$. Si $u<p$, se establece $B=cara$. Si no, $B=sello$. 

- Si se quiere simular el lanzamiento de un dado, se puede dividir el rango $[0.0, 1.0]$ en seis regiones, donde la $i$-ésima región corresponde a la $i$-ésima cara del dado. Luego, se extrae un valor $u$ desde la distribución $Uniforme(0,1)$. La cara del dado corresponderá a la región $[0.0, 1.0]$ en que $u$ caiga.

- Si queremos simular una v.a. $Exponencial$ (que veremos más adelante), se extrae $u$ desde una distribución $Uniforme(0,1)$, Luego se calcula $-Log(u)$.

:::

---

Digamos que conocemos la cdf $F_X()$ de una v.a., y que además, podemos computar la inversa de la cdf $F_X^{-1}(u)$, entonces:

- Entonces $F_X^{-1}(u)$ será una muestra de $X$ si $u$ es extraída desde una distribución $Uniforme$. 

- Las librerías computacionales que simulan v.a. usualmente muestrean desde la distribución $Uniforme$ como su operación fundamental.

---

### Ejercicios

Probar simulando distribuciones a partir de números pseudo-aleatorios, graficar los resultados y comprobar con el generador de distribuciones:

- Simular 1000 números aleatorios a partir de una distribución exponencial, con $\lambda = 0.5$ (fijarse en la parametrización del código).

- Simular 1000 números aleatorios a partir de una distribución normal, con $\mu = 10$, y $\sigma^2 = 3$.

- Simular 1000 números aleatorios a partir de una distribución chi-cuadrado, considere que el cuadrado de una distribución normal estándar se distribuye chi cuadrado con 1 grado de libertad.

---

### Transformación de variables y relación entre distribuciones

![Ejemplo de algunas relaciones entre distribuciones univariadas](images/distribution_relationship_map.png)

---

**Enlaces con información más detallada:**

- [Diagrama de relaciones entre distribuciones](https://www.johndcook.com/blog/distribution_chart/)

- [Un diagrama un poco más detallado](http://www.math.wm.edu/~leemis/chart/UDR/UDR.html)


# Generación de números pseudo-aleatorios {background-color="#00A499"}

## Contexto

- En los [primeros días]{.green} de la simulación, la aleatoriedad se generaba mediante [técnicas manuales]{.orange}: 

  - lanzamiento de monedas
  
  - lanzamiento de dados
  
  - barajada de cartas
  
  - giro de la ruleta

- Más tarde, se conectaron dispositivos físicos, como diodos de ruido y contadores Geiger, a las computadoras con el mismo propósito. 

- La creencia predominante sostenía que solo los dispositivos mecánicos o electrónicos podían producir secuencias verdaderamente aleatorias. 

---

- Aunque los dispositivos mecánicos todavía son de utilidad en el juego y las loterías, estos métodos ya no son empleados en aplicaciones computacionales y de análisis por varios motivos: 

  - Los métodos mecánicos eran demasiado lentos para uso general, 
  
  - las secuencias generadas no pueden ser reproducidas y, 
  
  - se ha encontrado que los números generados exhiben tanto sesgo como dependencia. 

. . . 

::: {.alert}
Aunque ciertos métodos físicos de generación modernos son rápidos y pasarían la mayoría de las pruebas estadísticas de aleatoriedad (por ejemplo, aquellos basados en la radiación de fondo universal o en el ruido de un chip de PC), su principal desventaja sigue siendo su falta de reproducibilidad 
:::

---

- La mayoría de los generadores de números aleatorios de hoy en día no se basan en dispositivos físicos, sino en algoritmos simples que se pueden implementar fácilmente en una computadora. 

- Son métodos rápidos, requieren poco espacio de almacenamiento y pueden reproducir fácilmente una secuencia dada de números aleatorios. 
  

::: {.alert}
  Es importante destacar que un buen generador de números aleatorios captura todas las propiedades estadísticas importantes de las secuencias aleatorias verdaderas, aunque la secuencia se genere mediante un algoritmo determinista. Por esta razón, a estos generadores a veces se les llama pseudorandom.
:::

---

El componente fundamental de un estudio de simulación es la capacidad de [generar números aleatorios]{.green}, donde un número aleatorio representa el [valor de una variable aleatoria distribuida uniformemente en (0,1)]{.green}.

Mientras que originalmente los números aleatorios se generaban manual o mecánicamente, utilizando técnicas como girar ruedas, lanzar dados o barajar cartas, el enfoque moderno es utilizar computación para generar sucesivamente números pseudo aleatorios Estos números pseudo aleatorios constituyen una secuencia de valores que, aunque se generan de manera determinista, tienen todas las apariencias de ser variables aleatorias uniformes independientes (0,1).

---

## Métodos Congruenciales

Consideremos la siguiente [secuencia de 100 números]{.green}, generada en R, parecen ser aleatorios, ¿cierto?:

::: {.alert}

```{r}
#| echo: false

x0 = 0
secuencia = c(x0)
n = 100
for (i in 1:n){
  aux = ((pi + secuencia[i])^5)%%1
  secuencia = c(secuencia, aux)
}
secuencia
```

:::

---

Los números pseudo aleatorios tienen la [*apariencia*]{.green} de ser aleatorios. Sin embargo son generados de una manera muy poco aleatoria. Tomemos por ejemplo la siguiente fórmula recursiva

$$ x_{i+1} = \mbox{parte fraccional de }(\pi + x_i )^5 \qquad \mbox{para } i\geq 0 $$

donde $x_0$ es un número dado que se encuentra en el rango $0 < x_0 < 1$

---

::: {.definition}
[Tarea: ]{.blue}</br>
Replicar la secuencia de números presentada anteriormente (en *R* y/o *Python*).
:::

---

Uno de los enfoques más comunes para generar números pseudo aleatorios comienza con un valor inicial $x_0$, llamado la [semilla]{.orange}, y luego calcula recursivamente los valores sucesivos $x_i$, para $i \geq 1$, dejando que

$$
x_{i+1} = a x_{i} + b \mod m
$$ {#eq-congruencial}

donde $a$ (multiplicador), $b$ (incremento) y $m$ (módulo) son constantes enteras positivas dadas, y donde lo anterior significa que $ax_{i}+b$ se divide por $m$ y el resto se toma como el valor de $x_{i+1}$. Así, cada $x_i$ es $0, 1, \ldots, m - 1$ y la cantidad $\frac{x_i}{m}$, llamada [número pseudo aleatorio]{.orange}, se toma como una aproximación al valor de la variable aleatoria uniforme (0,1) $\sim U(0,1)$.

---

Método Congruencial Aditivo
$$ x_i = (x_{i-1} + b) \mod m$$

Método Congruencial Multiplicativo
$$ x_i = a x_{i-1} \pmod m$$

Método Congruencial Mixto
$$ x_i = (a x_{i-1} + b) \pmod m$$

---

::: {.example}
[Ejemplos:]{.green}</br>

Probemos algunas combinaciones de parámetros y sus resultados:

- $x_0 = 89, a=1573, b=19, m=10^3$.

- $b=0, a=2^{16} + 3$ y $m=2^{31}$, generador *RANDU* de IBM. Este generador tiene varios problemas, que pueden ser descritos [acá](https://young.physics.ucsc.edu/115/randu.pdf). [Wolfram.com](https://demonstrations.wolfram.com/PoorStatisticalQualitiesForTheRANDURandomNumberGenerator/) entrega una visualización referente a este mismo problema.

- $b=0, a=7^5$ y $m=2^{31}-1$, el primo de Mersenne, empleado por librerías IMSL (*International Mathematics and Statistics Library*) y NAG *(Numerical Algorithms Group Ltd.*), propuesto por @Park1988.

- $b=0, a=48271$ y $m=2^31 -1$, actualización del anterior, propuesta por @Marsaglia1993.

:::

---

::: {.alert}
[Algunas consideraciones]{.blue}</br>

::: {.small}
- La [elección de las constantes $a, b$ y $m$]{.green} tiene un razonamiento que considera varios objetivos. Para empezar, se quiere que la [aritmética sea eficiente]{.orange}. Los seres humanos hacen aritmética en base 10, así que si la @eq-congruencial se operara manualmente, usando lápiz y papel, sería sensato que [$m$ fuera alguna potencia entera positiva de 10]{.orange}.

- Si uno calcula naturalmente en [base numérica $r$]{.green}, entonces la operación de división por $m$ es [más eficiente si $m = r^k$]{.orange} para algún entero positivo $k$.

  - Para la mayoría de los computadores, esto implica establecer $m = 2^k$, donde $k$ se selecciona para que $m$ sea "*grande*" y los números involucrados estén dentro de la precisión de la máquina.

:::
:::

---

::: {.definition}
[Definición:]{.blue}</br>

El generador de la @eq-congruencial no puede producir más de $m$ números diferentes antes de que el ciclo se repita. Sea $p$ el período de una secuencia, cuando $p$ es igual a su máximo, es decir, $p=m$. Decimos que el generador de números aleatorios [tiene un período completo]{.green}.
:::

--- 

::: {.alert}
[Teorema: Hull-Dobell (Generador de período completo)]{.green}</br>
Sea el Generador Congruencial Lineal (GCL) de la forma:
$$ x_i = (a x_{i-1} + b) \pmod m$$

Para $b > 0$, el GCL tiene un período completo si y solo si se cumplen las siguientes tres condiciones:

::: {.small}
i. El único entero positivo que divide exactamente tanto a $m$ como a $b$ es 1.

ii. Si $q$ es un número primo (divisible solo por sí mismo y 1) que divide a $m$, entonces $q$ divide a $(a-1)$. Es decir, $a \equiv 1 \pmod{q}$, para todo factor primo $q$ de $m$.

iii. Si 4 divide a $m$, entonces 4 divide a $(a-1)$. Es decir, $a \equiv 1 \pmod{4}$, si $m$ es múltiplo de 4.

- Si $m = 2^k$, la relación (iii) implicaría que $a = 4b + 1$ para $b$ entero positivo, lo cual también satisface la relación (ii).

- Cuando $m = 2^n$, la relación (i) se logra fácilmente estableciendo $b$ como cualquier constante positiva impar.
:::
:::

## Propiedades de los generadores congruenciales

::: {.definition}
Se podría esperar que los números resultantes del generador congruencial mixto (@eq-congruencial) tengan dependencias inusuales, y esto puede ser ilustrado en lo siguiente:

- Sea $x_{i+1} = 5x_i \pmod{m}$

- Aquí, $x_{i+1} = 5x_i - h_{i}m$, donde $h$ toma uno de los valores 0, 1, 2, 3, 4.

Por lo tanto, los pares de valores sucesivos $(x_i, x_{i+1})$ representan las coordenadas cartesianas de puntos que se encuentran en una de las cinco rectas dadas por la ecuación, y cuanto mayor es $m$, más larga será la secuencia de números generados que permanecerá en una de estas líneas antes de pasar a otra.

:::

---

::: {.example}
[Ejemplo:]{.green}</br>

Si $x_1 = 1$ y $m = 11$, entonces:
$$x_1 = 5, x_2 = 3, x_3 = 4, x_4 = 9, x_5 = 1$$

y la línea utilizada cambia con cada iteración.

Sin embargo, si $x_1 = 1$ y $m = 1000$, entonces:
$$x_1 = 5, x_2 = 25, x_3 = 125, x_4 = 625, x_5 = 125$$

y la secuencia de $x_1$ a $x_4$ se obtiene de la línea $x_{i+1} = 5x_i$, tras lo cual la secuencia degenera en una alternancia simple. Pares de valores sucesivos dan puntos que yacen en un número limitado de líneas rectas, tríos de valores sucesivos se encuentran en un número limitado de planos, etc.
:::

---

::: {.example}
[Ejemplo:]{.green}</br>

Si tomamos el generador congruencial dado por:
$$ x_{n-1} = 781 x_n + 387 \pmod{1000}$$
con $u_i = x_i/1000$, para $0 \leq i \leq 999$.


```{r}
#| echo: false
#| fig-align: center

library(tidyverse)
library(ggplot2)
x0 = 0
secuencia = c(x0)
n = 500
for (i in 1:n){
  aux = (387 + 781*secuencia[i])%%1000
  secuencia = c(secuencia, aux)
}

secuencia = secuencia/1000

u = data.frame(x=secuencia[1:n-1], 
               y=secuencia[2:n])

#this also works!
# embed(secuencia, 2)

u %>% 
  ggplot(aes(x, y)) +
  geom_point(colour="green4") +
  xlab(expression(x[i])) + ylab(expression(x[i+1])) +
  theme_minimal()
```

:::

---

::: {.alert}

- La [marcada tendencia de *vacíos*]{.green} en el plano se debe al pequeño valor de $m$ utilizado, lo que también permite observar el tipo de patrón que puede aparecer. Por lo tanto, en muchos casos, [se sugiere modificar la salida de los generadores]{.orange} congruenciales antes de ser utilizada, lo cual siempre implica una revisión. 

- Una manera de modificar la salida es [tomar los números en grupos de tamaño $g$, para luego *mezclarlos*]{.orange} mediante una permutación, antes de ser utilizados.
    - @Andrews1972 utiliza $g=500$.

    - @Egger1979 y @Atkinson1980 proponen $g=100$.

- Un enfoque alternativo, propuesto por @MacLaren1965, es tener un conjunto de $g$ números almacenados, a partir de generador congruencial, y elegir cuál de estos números usar a continuación mediante un dígito indicador aleatorio del rango 1 a $g$, obtenido, por ejemplo, por un generador congruencial separado. El lugar que dejó el número utilizado del conjunto es reemplazado entonces con el siguiente número del generador original, y así sucesivamente.
:::

---

::: {.example}
[Ejemplo:]{.green}</br>

```{r}
#| echo: false
#| fig-height: 8
#| fig-width: 16
#| fig-align: center

library(tidyverse)
library(forcats)
library(gridExtra)
library(ggplot2)

x0 = 0
secuencia = c(x0)
n = 500
for (i in 1:n){
  aux = (387 + 781*secuencia[i])%%1000
  secuencia = c(secuencia, aux)
}

secuencia = secuencia/1000

u = data.frame(x=secuencia[1:n-1], 
               y=secuencia[2:n])

#this also works!
# embed(secuencia, 2)

p1 = u %>% 
  ggplot(aes(x, y)) +
  geom_point(colour="green4") +
  xlab(expression(x[i])) + ylab(expression(x[i+1])) +
  theme_minimal() +
  labs(title = "Generador del ejemplo",
       subtitle = "Vacíos en los números generados")

# the other RNG method Egger (1979) and Atkinson (1980)
g = 100
secuencia2 = c()
for (i in 1:(n/g)){
  aux = c()
  aux = secuencia[((i-1)*g+1):(i*g)]
  aux = sample(aux, replace=FALSE)
  secuencia2 = c(secuencia2, aux)
}

u2 = data.frame(x=secuencia2[1:n-1], 
               y=secuencia2[2:n])

p2 = u2 %>% 
  ggplot(aes(x, y)) +
  geom_point(colour="green4") +
  xlab(expression(x[i])) + ylab(expression(x[i+1])) +
  theme_minimal() +
  labs(title = "Generador mejorado 1",
       subtitle = "Egger (1979) y Atkinson (1980)")

# MacLaren and Marsaglia (1965)
x0 = 0
secuencia = c(x0)
n = 520
for (i in 1:n){
  aux = (387 + 781*secuencia[i])%%1000
  secuencia = c(secuencia, aux)
}

secuencia = secuencia/1000

g = 20
pool = secuencia[2:(g+1)]
x0 = 0.5
seleccion = c(x0)
n = 500
for (i in 1:n){
  aux = ((pi + seleccion[i])^5)%%1
  seleccion = c(seleccion, aux)
}
seleccion = as.integer(round((seleccion[2:(n+1)]*(g-1)+1), digits=0))

n = 500
secuencia3 = rep(0, n)
for (i in 1:n){
  secuencia3[i] = pool[seleccion[i]]
  pool[seleccion[i]] = secuencia[(i+20)]
}

u3 = data.frame(x=secuencia3[1:n-1], 
                y=secuencia3[2:n])

p3 = u3 %>% 
  ggplot(aes(x, y)) +
  geom_point(colour="green4") +
  xlab(expression(x[i])) + ylab(expression(x[i+1])) +
  theme_minimal() +
  labs(title = "Generador mejorado 2",
       subtitle = "MacLaren y Marsaglia (1965)")


# Combine both plots using gridExtra
grid.arrange(p1, p2, p3, ncol=3)

```

:::

## Método de los Cuadrados Medios

Otra alternativa para generar números pseudo-aleatorios es utilizar el [Método de los Cuadrados Medios]{.green}. Este método tiene la desventaja de que en generan resulta en un período corto. Al aplicarlo repetidamente, el método [tiende a producir el mismo número de manera recurrente o entra en un ciclo]{.orange}, repitiendo una secuencia de números anterior, lo que resulta en un bucle infinito. Esto limita su efectividad para generar secuencias de números aleatorios confiables y variados.

---

::: {.definition .small}
[Método de los cuadrados medios]{.blue}</br>

Se inicia con un número entero positivo de cuatro dígitos $x_0$, posteriormente se debe seguir la siguiente secuencia:

1. Elevar al cuadrado $x_0$ para obtener un entero de hasta ocho dígitos; si es necesario, añadir ceros a la izquierda para que tenga exactamente ocho dígitos.

2. Tomar los cuatro dígitos del medio de este número de ocho dígitos como el siguiente número de cuatro dígitos $x_1$.

3. Colocar un punto decimal a la izquierda de $x_1$ para obtener el primer [número aleatorio $u_1 \sim U(0,1)$]{.green}.

4. Repetir los pasos 1 a 3 $n$ veces para generar un vector de números aleatorios de largo $n$.
:::

# Analizando la calidad de los números pseudo aleatorios


## Métodos de bondad de ajuste




## Ejercicios

1. Si $x0 = 5$ y $x_n = 3x_{n−1} \pmod{150}$, generar $x_1, \ldots, x_{100}$. Visualizar la secuencia generada en un histograma de frecuencias y comentar los resultados. 

2. Si $x_0 = 3$ y $x_n = (5x_{n−1} + 7) \pmod{200}$, generar $x_1, \ldots, x_{1000}$. Visualizar la secuencia generada en un histograma de frecuencias y comentar los resultados. 


# Referencias 

::: {#refs}
:::